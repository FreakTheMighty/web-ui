// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#library('codegen_component');

#import('dart:coreimpl');
#import('../../lib/html5parser/tokenkind.dart');
#import('../../lib/html5parser/htmltree.dart');
#import('../lib/world.dart');
#import('codegen.dart');
#import('compile.dart');
#import('utils.dart');

/** Web Component code generator. */
class CodegenComponent {
  static CodegenComponent _cg = const CodegenComponent();

  const CodegenComponent();

  static const String _ATTR_METHOD = "void attributeChanged(String attribute, "
      "String oldValue, String newValue)";
  static String attributeMethod(String className) {
    String spaces = Codegen.spaces(2);
    return "\n\n$spaces$_ATTR_METHOD {\n"
        "$spaces  print('$className attribute: "
        "\$attribute,\$oldValue,\$newValue');\n$spaces}\n";
  }

  /**
   * Emit the element getter and attributeChanged methods required for the
   * WebComponent interface that isn't emitted for a template.
   */
  static String emitWebComponentOverrides(String className) {
    String spaces = Codegen.spaces(2);
    return "${attributeMethod(className)}\n"
        "${spaces}Element get element => component.element;";
  }

  /**
   * Generate the class for a Web Component
   * [filename] passed in would be filename part (sans '.extension').
   */
  static String generate(int parentsPathCount, String libraryName,
                         String filename, ElemCG ecg) {
    // TODO(terry): Validate that the filename matches identifier:
    //              a..z || A..Z || _ [a..z || A..Z || 0..9 || _]*
    if (libraryName.indexOf('.') >= 0) {
      world.fatal("Bad library - $libraryName");
    }

    StringBuffer buff = new StringBuffer();
    int injectId = 0;         // Inject function id

    buff.add(Codegen.header(filename, libraryName, parentsPathCount));

    if (ecg.includes.length > 0) {
      buff.add("/** Below import from script tag in HTML file. */\n");
      for (var includeName in ecg.includes) {
        buff.add("#import('$includeName');\n");
      }
      buff.add("\n");
    }

    // Get first template; start generating the code. */
    CGBlock cgb = ecg.templateCG(1);
    if (cgb != null) {
      Expect.isTrue(ecg.isWebComponent);

      String clsName = ecg.className;
      String wcName = ecg.webComponentName;
      String constructor = "$clsName() : super('$wcName')";

      List<String> generatedClasses = cgb.webComponentCode(ecg, constructor);
      int genClassesCount = generatedClasses.length;
      for (int idx = 0; idx < genClassesCount; idx++) {
        var genCode = generatedClasses[idx];
        String classCode;
        if (idx == 0) {
          String userCode = _cg._emitUserCode(ecg);
          String code = "$userCode$genCode";
          classCode =
              Codegen.emitExtendsClassHeader(clsName, "Component", code);
        } else {
          clsName = "_Template_$idx";
          genCode ="$genCode${emitWebComponentOverrides("$wcName $clsName")}";
          classCode = Codegen.emitImplementsClassHeader(clsName, "WebComponent",
              genCode);
        }
        buff.add("$classCode\n");
      }
    }

    return buff.toString();
  }

  /** Emit user supplied code; code inside of <script> tag in web component. */
  String _emitUserCode(ElemCG ecg) {
    Expect.isTrue(ecg.isWebComponent);

    StringBuffer buff = new StringBuffer();

    buff.add("  /** User written code associated with this component "
        "'item.html'. */\n");
    buff.add(ecg.userCode);

    buff.add("\n");

    buff.add("  /** Autogenerated from the template. */\n");

    return buff.toString();
  }
}

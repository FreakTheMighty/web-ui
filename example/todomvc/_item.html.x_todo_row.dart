// Auto-generated from item.html.
// DO NOT EDIT.

library x_todo_row;

import 'dart:html' as autogenerated;
import 'package:web_components/watcher.dart' as autogenerated;

import 'dart:html';
import 'model.dart';
import 'package:web_components/web_component.dart';

class TodoItemComponent extends WebComponent {
  
  /** Autogenerated from the template. */
  
  /**
  * Shadow root for this component. We use 'var' to allow simulating shadow DOM
  * on browsers that don't support this feature.
  */
  var _root;
  var _todoItem;
  
  autogenerated.WatcherDisposer _stopWatcher_todoItem_1;
  
  autogenerated.WatcherDisposer _stopWatcher_todoItem_2;
  
  var ___e3;
  
  autogenerated.EventListener _listener_doubleClick_3;
  
  var ___e0;
  
  autogenerated.EventListener _listener_click_4;
  
  autogenerated.WatcherDisposer _stopWatcher___e0_5;
  
  var ___e1;
  
  autogenerated.WatcherDisposer _stopWatcher___e1_6;
  
  var ___e2;
  
  autogenerated.EventListener _listener_click_7;
  
  var ___e4;
  
  autogenerated.EventListener _listener_submit_8;
  
  var _edit;
  
  autogenerated.EventListener _listener_blur_9;
  
  autogenerated.EventListener _listener_keyUp_10;
  
  TodoItemComponent.forElement(e) : super.forElement(e) {
    _root = createShadowRoot();
  }
  
  void created_autogenerated() {
    if (_root is autogenerated.ShadowRoot) _root.applyAuthorStyles = true;
    
    _root.innerHTML = r'''
    <div id="todo-item" class="{{_editingClass}} {{_completedClass}}">
    <div class="view" data-action="doubleClick:edit" id="__e-3">
    <input class="toggle" type="checkbox" data-bind="checked:todo.done" id="__e-0">
    <label id="__e-1">{{todo.task}}</label>
    <button class="destroy" data-action="click:delete" id="__e-2"></button>
    </div>
    <form data-action="submit:update" id="__e-4">
    <input id="edit" class="edit" data-action="blur:update,keyUp:maybeCancel">
    </form>
    </div>
    ''';
    
    _todoItem = _root.query('#todo-item');
    
    ___e3 = _root.query('#__e-3');
    
    ___e0 = _root.query('#__e-0');
    
    ___e1 = _root.query('#__e-1');
    
    ___e2 = _root.query('#__e-2');
    
    ___e4 = _root.query('#__e-4');
    
    _edit = _root.query('#edit');
    
    // Call user-defined created();
    created();
  }
  
  void inserted_autogenerated() {
    _stopWatcher_todoItem_1 = autogenerated.watchAndInvoke(() => _editingClass, (e) {
      if (e.oldValue != null && e.oldValue != '') {
        _todoItem.classes.remove(e.oldValue);
      }
      if (e.newValue != null && e.newValue != '') {
        _todoItem.classes.add(e.newValue);
      }
    });
    
    _stopWatcher_todoItem_2 = autogenerated.watchAndInvoke(() => _completedClass, (e) {
      if (e.oldValue != null && e.oldValue != '') {
        _todoItem.classes.remove(e.oldValue);
      }
      if (e.newValue != null && e.newValue != '') {
        _todoItem.classes.add(e.newValue);
      }
    });
    
    _listener_doubleClick_3 = (e) {
      edit(e);
      autogenerated.dispatch();
    };
    ___e3.on.doubleClick.add(_listener_doubleClick_3);
    
    _listener_click_4 = (e) {
      todo.done = ___e0.checked;
      autogenerated.dispatch();
    };
    ___e0.on.click.add(_listener_click_4);
    
    _stopWatcher___e0_5 = autogenerated.watchAndInvoke(() => todo.done, (e) {
      ___e0.checked = e.newValue;
    });
    
    _stopWatcher___e1_6 = autogenerated.watchAndInvoke(() => todo.task, (e) {
      ___e1.innerHTML = '${todo.task}';
    });
    
    _listener_click_7 = (e) {
      delete(e);
      autogenerated.dispatch();
    };
    ___e2.on.click.add(_listener_click_7);
    
    _listener_submit_8 = (e) {
      update(e);
      autogenerated.dispatch();
    };
    ___e4.on.submit.add(_listener_submit_8);
    
    _listener_blur_9 = (e) {
      update(e);
      autogenerated.dispatch();
    };
    _edit.on.blur.add(_listener_blur_9);
    
    _listener_keyUp_10 = (e) {
      maybeCancel(e);
      autogenerated.dispatch();
    };
    _edit.on.keyUp.add(_listener_keyUp_10);
    
    // Call user-defined inserted();
    inserted();
  }
  
  void removed_autogenerated() {
    // Call user-defined removed();
    removed();
    
    _stopWatcher_todoItem_1();
    
    _stopWatcher_todoItem_2();
    
    ___e3.on.doubleClick.remove(_listener_doubleClick_3);
    _listener_doubleClick_3 = null;
    
    ___e0.on.click.remove(_listener_click_4);
    _listener_click_4 = null;
    
    _stopWatcher___e0_5();
    
    _stopWatcher___e1_6();
    
    ___e2.on.click.remove(_listener_click_7);
    _listener_click_7 = null;
    
    ___e4.on.submit.remove(_listener_submit_8);
    _listener_submit_8 = null;
    
    _edit.on.blur.remove(_listener_blur_9);
    _listener_blur_9 = null;
    
    _edit.on.keyUp.remove(_listener_keyUp_10);
    _listener_keyUp_10 = null;
    
  }
  
  /** Original code from the component. */
  
  Todo todo;
  bool _editing = false;
  
  String get _editingClass => _editing ? 'editing' : '';
  String get _completedClass => todo.done ? 'completed' : '';
  
  void edit(e) {
    // Note: we could preserve the old edit value if the user canceled their
    // edit and restarts, but then we'd need to provide a different user
    // gesture to get back to a clean state. For the current simple UI, clean
    // state is the right default--it matches how most programs operate.
    _edit.value = todo.task;
    _editing = true;
    
    // Need to focus after watcher.dispatch() makes the edit box visible
    // TODO(jmesserly): need a better way to handle this. Perhaps via
    // watchers, but but those are blocked on this bug:
    // https://github.com/dart-lang/dart-web-components/issues/53
    window.setTimeout(() {
      // IE doesn't support autofocus. Also in Firefox, it appears to only
      // work the first time. So use .focus().
      _edit.focus();
      // Move cursor to end on Firefox and IE.
      _edit.value = '';
      _edit.value = todo.task;
    }, 0);
  }
  
  void update(e) {
    e.preventDefault(); // don't submit the form
    if (!_editing) return; // bail if user canceled
    todo.task = _edit.value;
    _editing = false;
  }
  
  void maybeCancel(KeyboardEvent e) {
    // TODO(jmesserly): dart:html should have a KeyCodes enumeration.
    // http://code.google.com/p/dart/issues/detail?id=5540
    if (e.keyCode == 27/*ASCII Escape*/) {
      _editing = false;
    }
  }
  
  void delete(e) {
    var list = app.todos;
    var index = list.indexOf(todo);
    if (index != -1) {
      list.removeRange(index, 1);
    }
  }
}


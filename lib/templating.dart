// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/** Common utility functions used by code generated by the dwc compiler. */
library templating;

import 'dart:html';
import 'package:web_components/safe_html.dart';
import 'package:web_components/watcher.dart';

/** 
 * Removes all sibling nodes from `start.nextNode` until [end] (inclusive). For
 * convinience, this function returns [start].
 */
Node removeNodes(Node start, Node end) {
  while (start != end) {
    var prev = end.previousNode;
    end.remove();
    end = prev;
  }
  return start;
}

/**
 * Take the value of a bound expression and creates an HTML node with its value.
 * Normaly bindings are associated with text nodes, unless [binding] has the
 * [SafeHtml] type, in which case an html element is created for it.
 */
Node nodeForBinding(binding) => binding is SafeHtml
    ? new Element.html(binding.toString()) : new Text(binding.toString());

/**
 * Updates a data-bound [node] to a new [value]. If the new value is not
 * [SafeHtml] and the node is a [Text] node, then we update the node in place.
 * Otherwise, the node is replaced in the DOM tree and the new node is returned.
 */
Node updateBinding(value, Node node) {
  var isSafeHtml = value is SafeHtml;
  var stringValue = value.toString();
  if (!isSafeHtml && node is Text) {
    node.text = stringValue;
  } else {
    var old = node;
    node = isSafeHtml ? new Element.html(stringValue) : new Text(stringValue);
    old.replaceWith(node);
  }
  return node;
}

/**
 * Insert every node in [nodes] under [parent] before [reference]. [reference]
 * should be a child of [parent] or `null` if inserting at the end.
 */
void insertAllBefore(Node parent, Node reference, List<Node> nodes) {
  nodes.forEach((n) => parent.insertBefore(n, reference));
}

/** A function returning a css-class binding or null. See [bindCssClasses]. */
typedef String CssClassBinding();

/**
 * Bind the result of [exp] to the class attribute in [elem]. [exp] is a closure
 * that retuns a string or null. You can bind multiple class attributes by
 * calling this function several times. For example
 *
 *     var class1 = 'pretty';
 *     var class2 = 'selected';
 *     bindCssClasses(e, () => class1);
 *     bindCssClasses(e, () => class2);
 *
 * You can then independently change class1 and class2. If you set `class1` to
 * null, then `pretty` will be removed from `e.classes`, but `selected` will be
 * kept.
 */
WatcherDisposer bindCssClasses(Element elem, CssClassBinding exp) {
  return watchAndInvoke(exp, (e) {
    // TODO(sigmund): also support exp being a string with spaces
    // TODO(sigmund): also support exp being an array of strings
    if (e.oldValue != null && e.oldValue != '') {
      elem.classes.remove(e.oldValue);
    }
    if (e.newValue != null && e.newValue != '') {
      elem.classes.add(e.newValue);
    }
  });
}

/** A function returning a css-style definitions. */
typedef Map<String, String> StyleDefinitions();

/** Bind the result of [exp] to the style attribute in [elem]. */
WatcherDisposer bindStyle(Element elem, StyleDefinitions exp) {
  return watchAndInvoke(exp, (e) {
    if (e.oldValue is Map<String, String>) {
      var props = e.newValue;
      if (props is! Map<String, String>) props = const {};
      for (var property in e.oldValue.keys) {
        if (!props.containsKey(property)) {
          // Value will not be overwritten with new setting. Remove.
          elem.style.removeProperty(property);
        }
      }
    }
    if (e.newValue is! Map<String, String>) {
      throw new DataBindingError("Expected Map<String, String> value "
        "to data-style binding.");
    }
    e.newValue.forEach(elem.style.setProperty);
  });
}

/** An error thrown when data bindings are set up with incorrect data. */
class DataBindingError implements Error {
  final message;
  DataBindingError(this.message);
  toString() => "Data binding error: $message";
}

// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/** Collects several code emitters for the template tool. */
// TODO(sigmund): add visitor that applies all emitters on a component
// TODO(sigmund): add support for conditionals, so context is changed at that
// point.
library emitters;

import 'package:html5lib/dom.dart';
import 'package:html5lib/dom_parsing.dart';

import 'code_printer.dart';
import 'codegen.dart' as codegen;
import 'file_system/path.dart';
import 'files.dart';
import 'html5_utils.dart';
import 'info.dart';
import 'messages.dart';
import 'utils.dart';

/**
 * An emitter for a web component feature.  It collects all the logic for
 * emitting a particular feature (such as data-binding, event hookup) with
 * respect to a single HTML element.
 */
abstract class Emitter<T extends ElementInfo> {
  /** Element for which code is being emitted. */
  Element elem;

  /** Information about the element for which code is being emitted. */
  T elemInfo;

  Emitter(this.elem, this.elemInfo);

  /** Emit declarations needed by this emitter's feature. */
  void emitDeclarations(Context context) {}

  /** Emit feature-related statemetns in the `created` method. */
  void emitCreated(Context context) {}

  /** Emit feature-related statemetns in the `inserted` method. */
  void emitInserted(Context context) {}

  /** Emit feature-related statemetns in the `removed` method. */
  void emitRemoved(Context context) {}

  // The following are helper methods to make it simpler to write emitters.
  Context contextForChildren(Context context) => context;

  /** Generates a unique Dart identifier in the given [context]. */
  String newName(Context context, String prefix) =>
      '${prefix}${context.nextId()}';
}

/**
 * Context used by an emitter. Typically representing where to generate code
 * and additional information, such as total number of generated identifiers.
 */
class Context {
  final CodePrinter declarations;
  final CodePrinter createdMethod;
  final CodePrinter insertedMethod;
  final CodePrinter removedMethod;

  Context([CodePrinter declarations,
           CodePrinter createdMethod,
           CodePrinter insertedMethod,
           CodePrinter removedMethod])
      : this.declarations = getOrCreatePrinter(declarations),
        this.createdMethod = getOrCreatePrinter(createdMethod),
        this.insertedMethod = getOrCreatePrinter(insertedMethod),
        this.removedMethod = getOrCreatePrinter(removedMethod);

  // TODO(sigmund): keep separate counters for ids, listeners, watchers?
  int _totalIds = 0;
  int nextId() => ++_totalIds;

  static getOrCreatePrinter(CodePrinter p) => p != null ? p : new CodePrinter();
}

/**
 * Generates a field for any element that has either event listeners or data
 * bindings.
 */
class ElementFieldEmitter extends Emitter<ElementInfo> {
  ElementFieldEmitter(Element elem, ElementInfo info) : super(elem, info);

  void emitDeclarations(Context context) {
    var elemField = elemInfo.idAsIdentifier;
    if (elemField != null) {
      var type = htmlElementNames[elem.tagName];
      // Note: this will eventually be the component's class name if it is a
      // known x-tag.
      if (type == null) type = 'UnknownElement';
      context.declarations.add('autogenerated.$type $elemField;');
    }
  }

  void emitCreated(Context context) {
    var elemField = elemInfo.idAsIdentifier;
    if (elemField == null) return;

    var id = elemInfo.elementId;

    if (!inTemplate(elemInfo)) {
      context.createdMethod.add("$elemField = _root.query('#$id');");
    }
  }

  bool inTemplate(ElementInfo info) =>
      info.parent != null &&
      (info.parent is TemplateInfo || inTemplate(info.parent));
}

/**
 * Generates event listeners attached to a node and code that attaches/detaches
 * the listener.
 */
class EventListenerEmitter extends Emitter<ElementInfo> {

  EventListenerEmitter(Element elem, ElementInfo info) : super(elem, info);

  /** Generate a field for each listener, so it can be detached on `removed`. */
  void emitDeclarations(Context context) {
    elemInfo.events.forEach((name, events) {
      for (var event in events) {
        var listenerName = '_listener_${elemInfo.idAsIdentifier}_${name}_';
        event.listenerField = newName(context, listenerName);
        context.declarations.add(
          'autogenerated.EventListener ${event.listenerField};');
      }
    });
  }

  /** Define the listeners. */
  // TODO(sigmund): should the definition of listener be done in `created`?
  void emitInserted(Context context) {
    var elemField = elemInfo.idAsIdentifier;
    elemInfo.events.forEach((name, events) {
      for (var event in events) {
        var field = event.listenerField;
        context.insertedMethod.add('''
          $field = (e) {
            ${event.action(elemField, "e")};
            autogenerated.dispatch();
          };
          $elemField.on.${event.eventName}.add($field);
        ''');
      }
    });
  }

  /** Emit feature-related statements in the `removed` method. */
  void emitRemoved(Context context) {
    var elemField = elemInfo.idAsIdentifier;
    elemInfo.events.forEach((name, events) {
      for (var event in events) {
        var field = event.listenerField;
        context.removedMethod.add('''
          $elemField.on.${event.eventName}.remove($field);
          $field = null;
        ''');
      }
    });
  }
}

/** Generates watchers that listen on data changes and update a DOM element. */
class DataBindingEmitter extends Emitter<ElementInfo> {
  DataBindingEmitter(Element elem, ElementInfo info) : super(elem, info);

  /** Emit a field for each disposer function. */
  void emitDeclarations(Context context) {
    var elemField = elemInfo.idAsIdentifier;
    elemInfo.attributes.forEach((name, attrInfo) {
      attrInfo.stopperNames = [];
      attrInfo.bindings.forEach((b) {
        var stopperName = newName(context, '_stopWatcher${elemField}_');
        attrInfo.stopperNames.add(stopperName);
        context.declarations.add(
          'autogenerated.WatcherDisposer $stopperName;');
      });
    });

    if (elemInfo.contentBinding != null) {
      elemInfo.stopperName = newName(context, '_stopWatcher${elemField}_');
      context.declarations.add(
          'autogenerated.WatcherDisposer ${elemInfo.stopperName};');
    }

    // Declare stoppers for children text nodes with content binding.
    for (var childInfo in elemInfo.children) {
      if (childInfo.contentBinding != null) {
        var childField = elemInfo.idAsIdentifier;
        childInfo.stopperName = newName(context, '_stopWatcher${childField}_');
        context.declarations.add(
            'autogenerated.WatcherDisposer ${childInfo.stopperName};');
      }
    }

  }

  /** Watchers for each data binding. */
  void emitInserted(Context context) {
    var elemField = elemInfo.idAsIdentifier;

    // stop-functions for watchers associated with data-bound attributes
    elemInfo.attributes.forEach((name, attrInfo) {
      if (attrInfo.isClass) {
        for (int i = 0; i < attrInfo.bindings.length; i++) {
          var stopperName = attrInfo.stopperNames[i];
          var exp = attrInfo.bindings[i];
          context.insertedMethod.add('''
              $stopperName = autogenerated.watchAndInvoke(() => $exp, (e) {
                if (e.oldValue != null && e.oldValue != '') {
                  $elemField.classes.remove(e.oldValue);
                }
                if (e.newValue != null && e.newValue != '') {
                  $elemField.classes.add(e.newValue);
                }
              });
          ''');
        }
      } else {
        var val = attrInfo.boundValue;
        var stopperName = attrInfo.stopperNames[0];
        var setter;
        // TODO(sigmund): use setters when they are available (issue #112)
        //                Need to know if an attr is known for an element.
        if ((elem.tagName == 'input' &&
             (name == 'value' || name == 'checked')) ||
            name == 'hidden') {
          setter = name;
        } else {
          setter = 'attributes["$name"]';
        }
        context.insertedMethod.add('''
            $stopperName = autogenerated.watchAndInvoke(() => $val, (e) {
            $elemField.$setter = e.newValue;
            });
        ''');
      }
    });

    // Emit functions for any data-bound content on this element or children of
    // this element.
    _emitContentWatchInvoke(context, elemInfo, elemField);
    for (var childInfo in elemInfo.children) {
      _emitContentWatchInvoke(context, childInfo, elemField);
    }
  }

  /** stop-functions for watchers associated with data-bound content. */
  void _emitContentWatchInvoke(Context context, ElementInfo info,
                               String elemField) {
    if (info.contentBinding != null) {
      var stopperName = info.stopperName;
      // TODO(sigmund): track all subexpressions, not just the first one.
      var val = info.contentBinding;
      context.insertedMethod.add('''
          $stopperName = autogenerated.watchAndInvoke(() => $val, (e) {
            $elemField.innerHTML = ${info.contentExpression};
          });
      ''');
    }
  }


  /** Call the dispose method on all watchers. */
  void emitRemoved(Context context) {
    elemInfo.attributes.forEach((name, attrInfo) {
      attrInfo.stopperNames.forEach((stopperName) {
        context.removedMethod.add('$stopperName();');
      });
    });
    if (elemInfo.contentBinding != null) {
      context.removedMethod.add('${elemInfo.stopperName}();');
    }
    for (var childInfo in elemInfo.children) {
      if (childInfo.contentBinding != null) {
        context.removedMethod.add('${childInfo.stopperName}();');
      }
    }
  }
}

/**
 * Emits code for web component instantiation. For example, if the source has:
 *
 *     <x-hello>John</x-hello>
 *
 * And the component has been defined as:
 *
 *    <element name="x-hello" extends="div" constructor="HelloComponent">
 *      <template>Hello, <content>!</template>
 *      <script type="application/dart"></script>
 *    </element>
 *
 * This will ensure that the Dart HelloComponent for `x-hello` is created and
 * attached to the appropriate DOM node.
 *
 * Also, this copies values from the scope into the object at component creation
 * time, for example:
 *
 *     <x-foo data-value="bar:baz">
 *
 * This will set the "bar" property of FooComponent to be "baz".
 */
class ComponentInstanceEmitter extends Emitter<ElementInfo> {
  ComponentInstanceEmitter(Element elem, ElementInfo info) : super(elem, info);

  void emitCreated(Context context) {
    var component = elemInfo.component;
    if (component == null) return;

    var id = elemInfo.idAsIdentifier;
    context.createdMethod.add(
        'var component$id = new ${component.constructor}.forElement($id);');

    elemInfo.values.forEach((name, value) {
      context.createdMethod.add('component$id.$name = $value;');
    });

    context.createdMethod.add('component$id.created_autogenerated();')
                         .add('component$id.created();');
  }

  void emitInserted(Context context) {
    if (elemInfo.component == null) return;

    // Note: watchers are intentionally hooked up after inserted() has run,
    // in case it makes any changes to the data.
    var id = elemInfo.idAsIdentifier;
    context.insertedMethod.add('$id.xtag.inserted();')
                          .add('$id.xtag.inserted_autogenerated();');
  }

  void emitRemoved(Context context) {
    if (elemInfo.component == null) return;

    var id = elemInfo.idAsIdentifier;
    context.removedMethod.add('$id.xtag.removed_autogenerated();')
                         .add('$id.xtag.removed();');
  }
}

/** Emitter of template conditionals like `<template instantiate='if test'>`. */
class ConditionalEmitter extends Emitter<TemplateInfo> {
  final ElementInfo childInfo;
  final Element childNode;
  final CodePrinter childrenCreated = new CodePrinter();
  final CodePrinter childrenRemoved = new CodePrinter();
  final CodePrinter childrenInserted = new CodePrinter();

  ConditionalEmitter(Element elem, ElementInfo info, this.childNode,
                     this.childInfo) : super(elem, info);

  void emitDeclarations(Context context) {
    var id = childInfo.idAsIdentifier;
    if (id == null) {
      id = elemInfo.idAsIdentifier;
    }
    assert(id != null);
    context.declarations.add('''
        // Fields for template conditional '${elemInfo.ifCondition}'
        autogenerated.WatcherDisposer _stopWatcher_if$id;
    ''');
  }

  void emitCreated(Context context) {
  }

  void emitInserted(Context context) {
    var id = childInfo.idAsIdentifier;
    if (id == null) {
      id = elemInfo.idAsIdentifier;
    }
    assert(id != null);

    var condition = (elemInfo as TemplateInfo).ifCondition;
    context.insertedMethod.add('''
        _stopWatcher_if$id = autogenerated.watchAndInvoke(() =>
            $condition, (e) {
              bool showNow = e.newValue;
              if ($id != null && !showNow) {
                // Remove any listeners/watchers on children
    ''');
    context.insertedMethod.add(childrenRemoved);

    String createChildren = "";

    if (!childInfo.isTemplateElement) {
      String createNode;
      if (childNode.attributes.length > 0 || childNode.nodes.length > 0) {
        String html = childNode.outerHTML;
        createChildren = "$id = new autogenerated.Element.html('''${html}''');";
      } else {
        createChildren =
            "$id = new autogenerated.Element.tag('${childNode.tagName}');";
      }
    }

    context.insertedMethod.add('''
            // Remove the actual child
            $id.remove();
            $id = null;
          } else if ($id == null && showNow) {
            $createChildren
            // Initialize children
    ''');
    context.insertedMethod.add(childrenCreated);
    context.insertedMethod.add('${elemInfo.parentId}.nodes.add($id);');
    context.insertedMethod.add('// Attach listeners/watchers');
    context.insertedMethod.add(childrenInserted);
    context.insertedMethod.add('''

          }
        });
    ''');
  }

  void emitRemoved(Context context) {
    var id  = childInfo.idAsIdentifier;
    if (id == null) {
      id = elemInfo.idAsIdentifier;
    }
    assert(id != null);

    context.removedMethod.add('''
        _stopWatcher_if$id();
        if ($id != null) {
          $id.remove();
          // Remove any listeners/watchers on children
    ''');
    context.removedMethod.add(childrenRemoved);
    context.removedMethod.add('}');
  }

  Context contextForChildren(Context c) => new Context(
      c.declarations, childrenCreated, childrenInserted, childrenRemoved);
}


/**
 * Emitter of template lists like `<template iterate='item in items'>` or
 * `<td template iterate='item in items'>`.
 */
class ListEmitter extends Emitter<TemplateInfo> {
  final ElementInfo childInfo;
  final Element childNode;
  final CodePrinter childrenDeclarations = new CodePrinter();
  final CodePrinter childrenCreated = new CodePrinter();
  final CodePrinter childrenRemoved = new CodePrinter();
  final CodePrinter childrenInserted = new CodePrinter();

  ListEmitter(Element elem, TemplateInfo info, this.childNode, this.childInfo)
      : super(elem, info);

  String get elementName => elemInfo.idAsIdentifier;

  void emitDeclarations(Context context) {
    var id = childInfo.idAsIdentifier;
    assert(id != null);
    String iterExpr = '${elemInfo.loopVariable} in ${elemInfo.loopItems}';
    context.declarations.add('''
        // Fields for template list '$iterExpr'
        autogenerated.WatcherDisposer _stopWatcher$id;
        List<autogenerated.WatcherDisposer> _removeChild$id = [];

    ''');
  }

  void emitCreated(Context context) {}

  void emitInserted(Context context) {
    var id = childInfo.idAsIdentifier;

    String insertHtml = '';
    String removeHtml = '';

    // Should the child be created?
    bool canCreateChild = !childInfo.isTemplateElement;
    if (canCreateChild) {
      String createHtml;
      if (childNode.attributes.length > 0 || childNode.nodes.length > 0) {
        String html = childNode.outerHTML;
        createHtml = "$id = new autogenerated.Element.html('''$html''')";
      } else {
        createHtml =
            // TODO(terry): Create Element.tag with precise type, e.g.
            //              new ButtonElement().
            "$id = new autogenerated.Element.tag('${childNode.tagName}')";
      }

      insertHtml = '''
          $createHtml;
          ${elemInfo.parentId}.nodes.add($id);
      ''';

      removeHtml = '${elemInfo.parentId}.remove();';
    }

    var loopItems = elemInfo.loopItems;
    context.insertedMethod
        .add('''
        _stopWatcher$id = autogenerated.watchAndInvoke(() => $loopItems, (e) {
          ${elemInfo.parentId}.nodes.clear();
          for (var remover in _removeChild$id) remover();
          _removeChild$id.clear();
          for (var ${elemInfo.loopVariable} in $loopItems) {
    ''')
         .add(childrenDeclarations)
         .add(insertHtml);

    context.insertedMethod
        .add(childrenCreated)
        .add('// Attach listeners/watchers')
        .add(childrenInserted)
        .add('// Remember to unregister them')
        .add('_removeChild$id.add(() {')
        .add(removeHtml)
        .add(childrenRemoved)
        .add('});\n}\n});');
  }

  void emitRemoved(Context context) {
    var id = elemInfo.idAsIdentifier;
    var childId = childInfo.idAsIdentifier;
    context.removedMethod.add('''
        _stopWatcher$childId();
        for (var remover in _removeChild$childId) remover();
        _removeChild$childId.clear();
    ''');
  }

  Context contextForChildren(Context c) {
    return new Context(
      childrenDeclarations, childrenCreated, childrenInserted, childrenRemoved);
  }
}


// TODO(terry): Consider creating HTMLCodePrinter to eliminates _INDENTS.
/**
 * An visitor that applies [ElementFieldEmitter], [EventListenerEmitter],
 * [DataBindingEmitter], [DataValueEmitter], [ConditionalEmitter], and
 * [ListEmitter] recursively on a DOM tree.
 */
class HtmlEmitter extends InfoVisitor {
  final String _startTagName;
  final CodePrinter initialPage = new CodePrinter();
  var parent;
  Node stopEmitting;

  HtmlEmitter([this._startTagName]);

  String run(ElementInfo root) {
    visit(root);
    return initialPage.toString();
  }

  void visitTemplateInfo(TemplateInfo templateInfo) {
    // Invoke super to visit children.
    super.visitTemplateInfo(templateInfo);
  }

  /**
   * If the template is template tag for iterate or conditional then the
   * template is never emitted.  If the parent is a template iterate/conditional
   * then template is not emitted either.
   */
  bool isHiddenTemplateInfo(ElementInfo elementInfo) {
    var node = elementInfo.node;
    var parentInfo = elementInfo.parent;
    return (node.tagName == 'template' && elementInfo is TemplateInfo &&
            !elementInfo.useDomId &&
            (elementInfo.hasIfCondition || elementInfo.hasIterate)) ||
           (parentInfo is TemplateInfo &&
            (parentInfo.hasIfCondition || parentInfo.hasIterate));
  }

  void visitElementInfo(ElementInfo elementInfo) {
    if (!isHiddenTemplateInfo(elementInfo)) {
      Node node = elementInfo.node;

      _emitStartTag(node, elementInfo);

      // Don't start emitting until after the outer tag is encountered.
      if (stopEmitting == null &&
          (_startTagName == null || node.tagName == _startTagName)) {
        stopEmitting = node;
      }

      // Invoke super to visit children.
      super.visitElementInfo(elementInfo);

      // Stop emitting any HTML after the tag we first from.
      if (stopEmitting == node) {
        stopEmitting = null;
      }

      _emitEndTag(node);
    } else {
      var elemNode = elementInfo.parent.parent.node;
      // Outer-most template tag of a component should not be emitted unless
      // child of the template is another template iterate.
      if (stopEmitting.parent == elemNode && elemNode.tagName == 'element') {
        stopEmitting = elemNode;
        _emitStartTag(elementInfo.parent.node, elementInfo.parent);
      }
    }
  }

  void _emitStartTag(Node node, elementInfo) {
    if (stopEmitting != null) {
      if (node is Element) {
        initialPage.add("<${node.tagName}${_attributesToString(node)}>");
      } else if (node is Text && elementInfo.contentBinding == null) {
        initialPage.add(htmlSerializeEscape(node.value));
      }
    }
  }

  void _emitEndTag(Node node) {
    if (stopEmitting != null) {
      if (node is Element && !isVoidElement(node.tagName)) {
        initialPage.add("</${node.tagName}>");
      }
    }
  }

  String _attributesToString(Element elem) {
    var attrs = elem.attributes;
    if (attrs.length > 0) {
      StringBuffer str = new StringBuffer();
      attrs.forEach((key, v) {
        String attrValue = htmlSerializeEscape(v, attributeMode: true);
        str.add(' $key="$attrValue"');
      });

      return str.toString();
    }

    return "";
  }
}


/**
 * An visitor that applies [ElementFieldEmitter], [EventListenerEmitter],
 * [DataBindingEmitter], [DataValueEmitter], [ConditionalEmitter], and
 * [ListEmitter] recursively on a DOM tree.
 */
class RecursiveEmitter extends InfoVisitor {
  final FileInfo _fileInfo;
  Context _context;

  RecursiveEmitter(this._fileInfo) : _context = new Context();

  void visitTemplateInfo(TemplateInfo templateInfo) {
    // Invoke super to visit children.
    super.visitTemplateInfo(templateInfo);
  }

  void visitElementInfo(ElementInfo elementInfo) {
    assert(elementInfo != null);
    var node = elementInfo.node;
    if (node == null) {
      visitElementInfo(elementInfo);
      return;
    }

    if (node is Text) {
      return;
    }

    var emitters = [new ElementFieldEmitter(node, elementInfo),
        new EventListenerEmitter(node, elementInfo),
        new DataBindingEmitter(node, elementInfo),
        new ComponentInstanceEmitter(node, elementInfo)];

    var childContext = _context;
    if (elementInfo.hasIfCondition || elementInfo.hasIterate) {
      // Look for first Element.
      var childInfo;
      var childNode;

      for (var info in elementInfo.children) {
        var node = info.node;
        if (node is Element) {
          childInfo = info;
          childNode = node;
          break;
        }
      }

      if (elementInfo.hasIfCondition) {
        var condEmitter = new ConditionalEmitter(node, elementInfo, childNode,
            childInfo);
        emitters.add(condEmitter);
        childContext = condEmitter.contextForChildren(_context);
      } else if (elementInfo.hasIterate) {
        var listEmitter = new ListEmitter(node, elementInfo,  childNode,
            childInfo);
        emitters.add(listEmitter);
        childContext = listEmitter.contextForChildren(_context);
      }
    }

    emitters.forEach((e) {
      e.emitDeclarations(_context);
      e.emitCreated(_context);
      e.emitInserted(_context);
      e.emitRemoved(_context);
    });

    var oldContext = _context;
    _context = childContext;

    // Invoke super to visit children.
    super.visitElementInfo(elementInfo);

    _context = oldContext;
  }
}

/** Generates the class corresponding to a single web component. */
class WebComponentEmitter extends RecursiveEmitter {
  WebComponentEmitter(FileInfo info) : super(info);

  String run(ComponentInfo info, PathInfo pathInfo) {
    // If this derives from another component, ensure the lifecycle methods are
    // called in the superclass.
    if (info.extendsComponent != null) {
      _context.createdMethod.add('super.created_autogenerated();');
      _context.insertedMethod.add('super.inserted_autogenerated();');
      _context.removedMethod.add('super.removed_autogenerated();');
    }

    var elemInfo = info.elemInfo;

    // elemInfo is pointing at template tag (no attributes).
    assert(elemInfo.node.tagName == 'element');
    assert(elemInfo is ElementInfo);
    for (var childInfo in elemInfo.children) {
      var node = childInfo.node;
      if (node is Element && node.tagName == 'template') {
        elemInfo = childInfo;
        break;
      }
    }

    var html = new HtmlEmitter().run(elemInfo);

    if (info.element.attributes['apply-author-styles'] != null) {
      _context.createdMethod.add('if (_root is autogenerated.ShadowRoot) '
          '_root.applyAuthorStyles = true;');
      // TODO(jmesserly): warn at runtime if apply-author-styles was not set,
      // and we don't have Shadow DOM support? In that case, styles won't have
      // proper encapsulation.
    }
    if (info.template != null) {
      // TODO(jmesserly): we don't need to emit the HTML file for components
      // anymore, because we're handling it here.

      // TODO(jmesserly): we need to emit code to run the <content> distribution
      // algorithm for browsers without ShadowRoot support.

      _context.createdMethod.add("_root.innerHTML = '''")
          .addRaw(escapeDartString(html, triple: true))
          .addRaw("''';\n");
    }

    visit(elemInfo);

    bool hasExtends = info.extendsComponent != null;
    var codeInfo = info.userCode;
    if (codeInfo == null) {
      var superclass = hasExtends ? info.extendsComponent.constructor
          : 'autogenerated.WebComponent';
      var imports = hasExtends ? [] : [new DartDirectiveInfo('import',
          'package:web_components/web_component.dart', 'autogenerated')];
      codeInfo = new DartCodeInfo(null, null, imports,
          'class ${info.constructor} extends $superclass {\n}');
    }

    var code = codeInfo.code;
    var match = new RegExp('class ${info.constructor}[^{]*{').firstMatch(code);
    if (match != null) {
      var printer = new CodePrinter();
      var libraryName = (codeInfo.libraryName != null)
          ? codeInfo.libraryName
          : info.tagName.replaceAll(const RegExp('[-./]'), '_');
      printer.add(codegen.header(info.declaringFile.path, libraryName));

      // Add exisitng import, export, and part directives.
      for (var directive in codeInfo.directives) {
        printer.add(codegen.directiveText(directive, info, pathInfo));
      }

      // Add imports only for those components used by this component.
      var imports = info.usedComponents.keys.map(
          (c) => PathInfo.relativePath(info, c));

      if (hasExtends) {
        // Inject an import to the base component.
        printer.add(codegen.importList(
            [PathInfo.relativePath(info, info.extendsComponent)]));
      }

      printer.add(codegen.importList(imports))
          .add(code.substring(0, match.end))
          .add('\n')
          .add(codegen.componentCode(info.constructor,
              _context.declarations.formatString(1),
              _context.createdMethod.formatString(2),
              _context.insertedMethod.formatString(2),
              _context.removedMethod.formatString(2)))
          .add(code.substring(match.end));
      return printer.formatString();
    } else {
      messages.error('please provide a class definition '
          'for ${info.constructor}:\n $code', info.element.span,
          file: info.inputPath);
      return '';
    }
  }
}

/** Generates the class corresponding to the main html page. */
class MainPageEmitter extends RecursiveEmitter {
  MainPageEmitter(FileInfo fileInfo) : super(fileInfo);

  String run(Document document, PathInfo pathInfo) {
    var elemInfo = _fileInfo.bodyInfo.children[0];
    visit(elemInfo);

    // fix up the URLs to content that is not modified by the compiler
    document.queryAll('script').forEach((tag) {
    var src = tag.attributes["src"];
     if (tag.attributes['type'] != 'application/dart' && src != null) {
       tag.attributes["src"] = pathInfo.transformUrl(_fileInfo, src);
     }
    });
    document.queryAll('link').forEach((tag) {
     var href = tag.attributes['href'];
       if (tag.attributes['rel'] != 'components' && href != null) {
         tag.attributes['href'] = pathInfo.transformUrl(_fileInfo, href);
       }
     });

    var printer = new CodePrinter();

    // Inject library name if not pressent.
    var codeInfo = _fileInfo.userCode;
    var libraryName = codeInfo.libraryName != null
        ? codeInfo.libraryName : _fileInfo.libraryName;
    printer.add(codegen.header(_fileInfo.path, libraryName));

    // Add exisitng import, export, and part directives.
    for (var directive in codeInfo.directives) {
      printer.add(codegen.directiveText(directive, _fileInfo, pathInfo));
    }

    // Import only those components used by the page.
    var imports = _fileInfo.usedComponents.keys.map(
          (c) => PathInfo.relativePath(_fileInfo, c));
    printer.add(codegen.importList(imports))
        .addRaw(codegen.mainDartCode(codeInfo.code,
            _context.declarations.formatString(0),
            _context.createdMethod.formatString(1),
            _context.insertedMethod.formatString(1),
            new HtmlEmitter('body').run(elemInfo)));
    return printer.formatString();
  }
}
